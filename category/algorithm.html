<!DOCTYPE html>
<html lang="japanese">
<head>
        <meta charset="utf-8" />
        <title>sassea34's blog - Algorithm</title>
        <link rel="stylesheet" href="https://sassea34.github.io/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://sassea34.github.io/">sassea34's blog </a></h1>
                <nav><ul>
                    <li class="active"><a href="https://sassea34.github.io/category/algorithm.html">Algorithm</a></li>
                    <li><a href="https://sassea34.github.io/category/deep-learning.html">Deep Learning</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://sassea34.github.io/sortarugorizumunobi-jiao.html">Sortアルゴリズムの比較</a></h1>
<footer class="post-info">
        <span>水 14 8月 2019</span>

</footer><!-- /.post-info --><h1>Sortアルゴリズムの勉強</h1>
<h2>目的</h2>
<ul>
<li>Sortアルゴリズムを改めて勉強する。<ul>
<li>参考書籍「プログラミングコンテスト攻略のためのアルゴリズムとデータ構造」</li>
</ul>
</li>
<li>一覧化／およびPythonでコーディングして知識整理を行い、再コーディング時に自走出来るようにする。</li>
</ul>
<hr>
<h2>アルゴリズム一覧</h2>
<table>
<thead>
<tr>
<th align="right">No</th>
<th>アルゴリズム</th>
<th>方法</th>
<th>特徴</th>
<th>ソート完了タイミング</th>
<th>外ループ i の方向性</th>
<th>内ループ j の方向性</th>
<th>オーダー</th>
<th>安定か？</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">1</td>
<td>Insertion Sort</td>
<td>注目セルの代入箇所を確認し、トランプを先頭から並べるかのように挿入していく。</td>
<td>ある程度整列されたデータに対しては高速<br>(比較演算がデータ依存)<hr>操作済みの部分に絞ってはソート済みの状態が出来る。</td>
<td>最後</td>
<td _leqq="\leqq">左から右（正順）<hr>$1</td>
<td _geqq="\geqq">iを保存、i-1から左へ。（挿入箇所を探索して入れ替え）<hr>$i-1</td>
<td>$O(n^2)$</td>
<td>安定</td>
</tr>
<tr>
<td align="right">2</td>
<td>Bubble Sort</td>
<td>未整列の残り部分の末端から先頭へ、隣同士の２つのセルを比較し、小値であれば２つを交換していく。</td>
<td>交換回数は反転数、転倒数と呼ばれ、列の乱れの具合を表す。</td>
<td>先頭から確定</td>
<td _geqq="\geqq">右から左（逆順）<hr>$N-1</td>
<td>内ループ無し</td>
<td>$O(n^2)$</td>
<td>安定</td>
</tr>
<tr>
<td align="right">3</td>
<td>Selection Sort</td>
<td>最小のセルを抽出しながら、先頭と置き換えていく。</td>
<td>離れた対象を比較、入れ替えるため安定ではない</td>
<td>先頭から確定</td>
<td _leqq="\leqq">左から右（正順）<hr>$0</td>
<td _leqq="\leqq">左から右（正順）<hr>$i+1</td>
<td>$O(n^2)$</td>
<td>安定では無い</td>
</tr>
<tr>
<td align="right">4</td>
<td>Shell Sort</td>
<td>対象の数列をある数値間隔 $g$ で飛ばした数列とみなして、Insertion Sortをラフに行う。<br>上記をInsertion Sortの上位ループとして繰り返すことで、全体としての計算量を抑制するやり方。</td>
<td n_1="n+1">gの与え方はm段階だと（任意に）設定する。<br>例えば段階の数$m=3$のとき、$G_i={13,4,1}$のように$g_</td>
<td>最後</td>
<td>Insertion Sortを $g$ 拡張し、上位ループを左記の$G_i$により回す。</td>
<td>略（内部ループとしてはInsertion Sortとも位置付けられるか）</td>
<td 1.25>$O(n^</td>
<td>安定では無い<hr>未検証。予想として間隔$g$で飛ばしたソートを含むため。</td>
</tr>
</tbody>
</table>
<h3>No4 Shell Sortについて</h3>
<ul>
<li>これだけ考え方が難しいが、きっと以下の考え方で合っている？！<ol>
<li><code>対象の数列をある数値間隔 g で飛ばした数列とみなして</code>の部分は、Insertion Sortの内部における、外ループ i（No1を参照）のそれぞれのiの界が独立だと考えられる。<ul>
<li>究極はここをマルチスレッド化しても良い？</li>
</ul>
</li>
<li>よって、Insertion Sortの<code>ある程度整列されたデータに対しては高速</code>である特性を活かすために、以下を変数とする知見が必要になるのでは無いか？<ul>
<li>どれだけ大きな数列に対し</li>
<li>どれだけラフに上記表中の $G_i={13,4,1}$ を設定するか（もちろん$m$もいくつに設定するか）<ul>
<li>$g_{n+1}=3*g_n+1$ の <code>+1</code>がきっと重要（＝ずらす意味が）あるのだろう。<ul>
<li>$g_{n+1}=3*g_n+1$ の導出に関しては、今はこれ以上は疑問を持たないこととする。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2>Python Coding Tips</h2>
<ol>
<li>マルチライン入力<ul>
<li>AIZU ONLINE JUDGEの例題を利用したため、マルチライン入力を受け付けるコードが必要となった。</li>
<li>
<p>以下で、1行目に数列の数、2行目に数列を空白区切りで入力して受け付ける。</p>
<p><code>python
if __name__ == "__main__":
    # input by multi-line
    N = int(input())
    A = [int(word) for word in input().split()]</code>
1. アルファベット1文字＋数字1文字のデータの分解
    * <code>H9</code>などを2次元のlistで扱うコード。dictionaryよりlistで扱ったほうが入れ替えが出来て楽。</p>
<p><code>python
if __name__ == "__main__":
    # input by multi-line
    N = int(input())
    A = [int(word) for word in input().split()]
    B = [ [mark, num] for mark, num in list(A) ]</code>
1. listの要素の置換
    * 超基本ではあるけれど...</p>
<p><code>python
A[i], A[j] = A[j], A[i]</code>
1. listを空白区切りで出力
    * 入力と同様の形式での標準出力</p>
<p><code>python
print(" ".join(map(str, A)))</code>    </p>
<hr>
<h2>まとめ</h2>
<h3>学習したこと</h3>
<ol>
<li>書籍に従い、4つのアルゴリズムを整理することは出来た。</li>
<li>扱った中ではShell Sortが、オーダーが良いので使えると良いか？（多分、まだメリットデメリットが分かっていないかも）</li>
<li>プログラミングに慣れる意味では、ソートアルゴリズムは良いかもしれないし、真にはもっと深いらしい。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3>残課題</h3>
<ul>
<li>WiKi参考に、まだ独自実装できていないソート。</li>
<li>うち赤字は何となく手を出したい気がするもの。<ul>
<li>交換<ul>
<li>シェーカーソート</li>
<li>コムソート</li>
<li>ノームソート</li>
<li>奇遇転置ソート</li>
<li>シェアソート</li>
</ul>
</li>
<li>挿入<ul>
<li>２分木ソート（平衡２分探索木）</li>
<li>図書館ソート</li>
<li>ペイシェンスソート</li>
</ul>
</li>
<li>マージ<ul>
<li><font color="red">マージソート</font><ul>
<li>分解と併合によるもの。</li>
</ul>
</li>
<li>In-placeマージソート</li>
</ul>
</li>
<li>選択<ul>
<li><font color="red">ヒープソート</font><ul>
<li>二分木を使う。</li>
</ul>
</li>
<li>スムースソート</li>
<li>ストランドソート</li>
</ul>
</li>
<li>パーティショニング<ul>
<li><font color="red">クイックソート</font><ul>
<li>ピボットで分割、中央値等の工夫。</li>
</ul>
</li>
</ul>
</li>
<li>混成<ul>
<li>イントロソート</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上</p>                </article>
<p class="paginator">
    Page 1 / 1
</p>
            </aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://github.com/sassea34">GitHub</a></li>
                            <li><a href="http://www.z-z.jp/?sassea34">Message board</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>